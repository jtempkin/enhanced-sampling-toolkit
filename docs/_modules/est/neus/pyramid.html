<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>est.neus.pyramid &#8212; Enhanced Sampling Toolkit 0.1a documentation</title>
    
    <link rel="stylesheet" href="../../../_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.1a',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body role="document">

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Enhanced Sampling Toolkit 0.1a documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for est.neus.pyramid</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Class definition for Pyramid shaped window. Inherets from Window.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">.window</span> <span class="k">import</span> <span class="n">Window</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">collections</span>


<div class="viewcode-block" id="Pyramid"><a class="viewcode-back" href="../../../neus.html#est.neus.pyramid.Pyramid">[docs]</a><span class="k">class</span> <span class="nc">Pyramid</span><span class="p">(</span><span class="n">Window</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class definition of Pyramid which inherits from window. Implements the pyramid shaped basis function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Pyramid.__init__"><a class="viewcode-back" href="../../../neus.html#est.neus.pyramid.Pyramid.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">ref_center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ref_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">periodic_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_list_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">initial_conditions</span><span class="o">=</span><span class="p">[],</span> <span class="n">initial_conditions_probability</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an intsance of the Pyramid object.</span>

<span class="sd">        Note that the width parameter refers to the maximum distance in each direction for which this window is defined to have nonzero support.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------------</span>
<span class="sd">        center : numpy.ndarray, list</span>
<span class="sd">            The coordinates of the center of the window support.</span>

<span class="sd">        width : numpy.ndarray, list</span>
<span class="sd">            The width of the support of the window.</span>

<span class="sd">        ref_center : numpy.ndarray, list (None)</span>
<span class="sd">            The center of the support in the reference configuration at time :math:`t=0`</span>

<span class="sd">        ref_width : numpy.ndarray, list (None)</span>
<span class="sd">            The width of the support of the reference configuration at time :math:`t=0`</span>

<span class="sd">        time : numpy.ndarray, list (None)</span>
<span class="sd">            The time interval for which this window has nonzero support.</span>

<span class="sd">        periodic_length : numpy.ndarray, list (None)</span>
<span class="sd">            The length of the periodicity for each coordinate this window supports.</span>

<span class="sd">        max_list_size : interval (100)</span>
<span class="sd">            The maximum size of each :math:`\gamma_{ij}` distribution.</span>

<span class="sd">        initial_conditions : iterable</span>
<span class="sd">            The iterable of entry point objects at time :math:`t=0`.</span>

<span class="sd">        initial_conditions_probability : float</span>
<span class="sd">            A float between 0.0 and 1.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># call parent constructor</span>
        <span class="n">Window</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">ref_center</span><span class="o">=</span><span class="n">ref_center</span><span class="p">,</span> <span class="n">ref_width</span><span class="o">=</span><span class="n">ref_width</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span> <span class="n">periodic_length</span><span class="o">=</span><span class="n">periodic_length</span><span class="p">,</span> <span class="n">max_list_size</span><span class="o">=</span><span class="n">max_list_size</span><span class="p">,</span> <span class="n">initial_conditions</span><span class="o">=</span><span class="n">initial_conditions</span><span class="p">,</span> <span class="n">initial_conditions_probability</span><span class="o">=</span><span class="n">initial_conditions_probability</span><span class="p">)</span>

        <span class="c1"># We calculate the slope of the pyramid.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slopes</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span>

        <span class="k">return</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the string represetation of the Pyramid instance.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        string</span>
<span class="sd">            A string representation of the Pyramid instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="s2">&quot;Pyramid(&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>

        <span class="k">return</span> <span class="nb">id</span>

<div class="viewcode-block" id="Pyramid.__call__"><a class="viewcode-back" href="../../../neus.html#est.neus.pyramid.Pyramid.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">walker</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the value of the support for this Pyramid object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------</span>
<span class="sd">        walker : walker instance</span>
<span class="sd">            The walker instance for which to evaluate the support of the Pyramid.</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------</span>
<span class="sd">        float</span>
<span class="sd">            The value of the support.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># DEVLEOPER Note: this is the key for how the NEUS application module relies on the walker object definition. We have to think carefully about how exactly we want the window object accept input in the call function. Should this explicitly make assumptions about the structure and callable functions of the walker class or should we try to generalize this to act through something like a numpy array?</span>

        <span class="c1"># second comment: This question arises separately really from how we wish this call function is implemented from a partition object. The partition object will</span>

        <span class="c1"># ok, here we are going to implement the window on top if the walker object definition. But we will enforce that the behavoir of Pyramid&#39;s call will depend on both the definition of the reference and the information it can get from walker.</span>

        <span class="c1"># check to see that we&#39;ve received a walker object</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">walker</span><span class="o">.</span><span class="n">get_colvars</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">walker</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">coord</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;walker collective variables array does not match the shape of this window instance definition.&quot;</span>

        <span class="c1"># create a distance vector</span>
        <span class="n">distancevec</span> <span class="o">=</span> <span class="n">coord</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span>

        <span class="c1"># if any collective variable is periodic, construct dr, the adjuct for minimum image convention for the periodic cv&#39;s</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapping</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># build dr</span>
            <span class="n">dr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">distancevec</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="c1"># add values to dr if the CV wraps</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapping</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapping</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="c1"># This is an old trick from MD codes to find the minimum distance between two points.</span>
                    <span class="n">dr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapping</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">distancevec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapping</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="c1"># add min image vector</span>
            <span class="n">distancevec</span> <span class="o">-=</span> <span class="n">dr</span>

        <span class="c1"># We calculate the value of</span>
        <span class="n">psiparts</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">slopes</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">distancevec</span><span class="p">)</span>

        <span class="n">val</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">psiparts</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_center</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># check to see that</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">walker</span><span class="p">,</span> <span class="s2">&quot;get_initial_colvars&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Walker object passed to Pyramid __call__ does not have support for getting refernce collective variable value.&quot;</span><span class="p">)</span>

            <span class="c1"># return initial state of the collective variable</span>
            <span class="n">ref_coord</span> <span class="o">=</span> <span class="n">walker</span><span class="o">.</span><span class="n">get_initial_colvars</span><span class="p">()</span>

            <span class="n">val</span> <span class="o">*=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_indicator</span><span class="p">(</span><span class="n">ref_coord</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># check that the passed walker object has a time coordinate</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">walker</span><span class="p">,</span> <span class="s2">&quot;get_time&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Walker object passed to Pyramid __call__ does not have support for getting time value.&quot;</span><span class="p">)</span>

            <span class="c1"># get time</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">walker</span><span class="o">.</span><span class="n">get_time</span><span class="p">()</span>

            <span class="c1"># return indicator and multiply against support value</span>
            <span class="n">val</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_indicator</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>


        <span class="c1">#  return the minimum value.</span>
        <span class="k">return</span> <span class="n">val</span></div>

<div class="viewcode-block" id="Pyramid.ref_indicator"><a class="viewcode-back" href="../../../neus.html#est.neus.pyramid.Pyramid.ref_indicator">[docs]</a>    <span class="k">def</span> <span class="nf">ref_indicator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the value of the support for the reference phase space point.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------</span>
<span class="sd">        coord : numpy.ndarray</span>
<span class="sd">            The coordinates of the reference phase space point.</span>

<span class="sd">        Returns</span>
<span class="sd">        ------------</span>
<span class="sd">        float</span>
<span class="sd">            The value of the support on the reference coordinate.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">coord</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_center</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;walker reference collective variables array does not match the shape of this window reference center.&quot;</span>

        <span class="c1"># create a distance vector</span>
        <span class="n">distancevec</span> <span class="o">=</span> <span class="n">coord</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_center</span>

        <span class="c1"># if any collective variable is periodic, construct dr, the adjuct for minimum image convetion for the periodic cv&#39;s</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapping</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># build dr</span>
            <span class="n">dr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">distancevec</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="c1"># add values to dr if the CV wraps</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapping</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapping</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="c1"># This is an old trick from MD codes to find the minimum distance between two points.</span>
                    <span class="n">dr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapping</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">distancevec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapping</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="c1"># add min image vector</span>
            <span class="n">distancevec</span> <span class="o">-=</span> <span class="n">dr</span>

        <span class="c1"># We return 1.0 if all the distances are smaller than the width of the box from the center, 0.0 otherwise.</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_width</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">distancevec</span><span class="p">)))</span></div>

<div class="viewcode-block" id="Pyramid.time_indicator"><a class="viewcode-back" href="../../../neus.html#est.neus.pyramid.Pyramid.time_indicator">[docs]</a>    <span class="k">def</span> <span class="nf">time_indicator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the indicator function on the time interval.</span>

<span class="sd">        Takes the value 1.0 if the time provided is in the time interval for which this window has nonzero support.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        time : int</span>
<span class="sd">            A time to evaluate.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        float</span>
<span class="sd">            The indicator value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_start</span> <span class="o">&lt;=</span> <span class="n">time</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_end</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Enhanced Sampling Toolkit 0.1a documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2015, Jeremy O. B. Tempkin.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1.
    </div>
  </body>
</html>